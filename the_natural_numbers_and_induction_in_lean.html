
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>18. The Natural Numbers and Induction in Lean &#8212; Logic and Proof 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="19. Elementary Number Theory" href="elementary_number_theory.html" />
    <link rel="prev" title="17. The Natural Numbers and Induction" href="the_natural_numbers_and_induction.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-natural-numbers-and-induction-in-lean">
<span id="id1"></span><h1>18. The Natural Numbers and Induction in Lean<a class="headerlink" href="#the-natural-numbers-and-induction-in-lean" title="Permalink to this headline">&#182;</a></h1>
<p>The goal of this chapter is to give a more axiomatic, foundational account of the natural numbers and its basic operations. First, we will do this informally, showing how operations like addition and multiplication can be defined using the principle of recursion, and showing how some of their basic properties can be proved using induction. Then we will see how this plays out in the Lean theorem prover, using Lean&#8217;s built-in mechanisms for induction and recursion.</p>
<div class="section" id="defining-arithmetic-operations">
<span id="id2"></span><h2>18.1. Defining Arithmetic Operations<a class="headerlink" href="#defining-arithmetic-operations" title="Permalink to this headline">&#182;</a></h2>
<p>Let <span class="math">\(\mathbb{N}\)</span> be the set of natural numbers with least element <span class="math">\(0\)</span>, and let <span class="math">\(\mathrm{succ}(m) = m + 1\)</span> be the successor function. The structure <span class="math">\(( \mathbb{N}, 0, \mathrm{succ} )\)</span> satisfies the following clauses:</p>
<ul class="simple">
<li><span class="math">\(0 \neq \mathrm{succ}(m)\)</span> for any <span class="math">\(m\)</span> in <span class="math">\(\mathbb{N}\)</span>.</li>
<li>For every <span class="math">\(m\)</span> and <span class="math">\(n\)</span> in <span class="math">\(\mathbb{N}\)</span>, if <span class="math">\(m \neq n\)</span>, then <span class="math">\(\mathrm{succ}(m) \neq \mathrm{succ}(n)\)</span>. In other words, <span class="math">\(\mathrm{succ}\)</span> is <em>injective</em>.</li>
<li>If <span class="math">\(A\)</span> is any subset of <span class="math">\(\mathbb{N}\)</span> with the property that <span class="math">\(0\)</span> is in <span class="math">\(A\)</span> and whenever <span class="math">\(n\)</span> is in <span class="math">\(A\)</span> then <span class="math">\(\mathrm{succ}(n)\)</span> is in <span class="math">\(A\)</span>, then <span class="math">\(A = \mathbb{N}\)</span>.</li>
</ul>
<p>The last clause can be reformulated as the principle of induction:</p>
<blockquote>
<div>Suppose <span class="math">\(P(n)\)</span> is any property of natural numbers, such that <span class="math">\(P\)</span> holds of <span class="math">\(0\)</span>, and for every <span class="math">\(n\)</span>, <span class="math">\(P(n)\)</span> implies <span class="math">\(P(\mathrm{succ}(n))\)</span>. Then every <span class="math">\(P\)</span> holds of every natural number.</div></blockquote>
<p>Remember that this principle can be used to justify the principle of definition by recursion:</p>
<blockquote>
<div><p>Let <span class="math">\(A\)</span> be any set, <span class="math">\(a\)</span> be any element of <span class="math">\(A\)</span>, and let <span class="math">\(g(n,m)\)</span> be any function from <span class="math">\(\mathbb{N} \times A\)</span> to <span class="math">\(A\)</span>. Then there is a unique function <span class="math">\(f: \mathbb{N} \to A\)</span> satisfying the following two clauses:</p>
<ul class="simple">
<li><span class="math">\(f(0) = a\)</span></li>
<li><span class="math">\(f(\mathrm{succ}(n)) = g(n,f(n))\)</span> for every <span class="math">\(n\)</span> in <span class="math">\(N\)</span>.</li>
</ul>
</div></blockquote>
<p>We can use the principle of recursive definition to define addition with the following two clauses:</p>
<div class="math">
\[\begin{split}m + 0 &amp; = m \\
m + \mathrm{succ}(n) &amp; = \mathrm{succ}(m + n)\end{split}\]</div>
<p>Note that we are fixing <span class="math">\(m\)</span>, and viewing this as a function of <span class="math">\(n\)</span>. If we write <span class="math">\(1 = \mathrm{succ}(0)\)</span>, <span class="math">\(2 = \mathrm{succ}(1)\)</span>, and so on, it is easy to prove <span class="math">\(n + 1 = \mathrm{succ}(n)\)</span> from the definition of addition.</p>
<p>We can proceed to define multiplication using the following two clauses:</p>
<div class="math">
\[\begin{split}m \cdot 0 &amp; = 0 \\
m \cdot \mathrm{succ}(n) &amp; = m \cdot n + m\end{split}\]</div>
<p>We can also define a predecessor function by</p>
<div class="math">
\[\begin{split}\mathrm{pred}(0) &amp; = 0 \\
\mathrm{pred}(\mathrm{succ}(n)) &amp; = n,\end{split}\]</div>
<p>and ``truncated subtraction&#8217;&#8217; by</p>
<div class="math">
\[\begin{split}m \dot - 0 &amp; = 0 \\
m \dot - (\mathrm{succ}(n)) &amp; = \mathrm{pred}(m \dot - n).\end{split}\]</div>
<p>With these definitions and the induction principle, one can prove all the following identities:</p>
<ul class="simple">
<li><span class="math">\(n \neq 0\)</span> implies <span class="math">\(\mathrm{succ}(\mathrm{pred}(n)) = n\)</span></li>
<li><span class="math">\(0 + n = n\)</span></li>
<li><span class="math">\(\mathrm{succ}(m) + n = \mathrm{succ}(m + n)\)</span></li>
<li><span class="math">\((m + n) + k = m + (n + k)\)</span></li>
<li><span class="math">\(m + n = n + m\)</span></li>
<li><span class="math">\(m(n + k) = mn + mk\)</span></li>
<li><span class="math">\(0 \cdot n = 0\)</span></li>
<li><span class="math">\(1 \cdot n = x\)</span></li>
<li><span class="math">\((mn)k = m(nk)\)</span></li>
<li><span class="math">\(mn = nm\)</span></li>
</ul>
<p>We will do the first five here, and leave the remaining ones as exercises.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> For every natural number <span class="math">\(n\)</span>, if <span class="math">\(n \neq 0\)</span> then <span class="math">\(\mathrm{succ}(\mathrm{pred}(n)) = n\)</span>.</p>
<p><strong>Proof.</strong> By induction on <span class="math">\(n\)</span>. We have ruled out the case where <span class="math">\(n\)</span> is <span class="math">\(0\)</span>, so we only need to show that the claim holds for <span class="math">\(\mathrm{succ}(n)\)</span>. But in that case, we have <span class="math">\(\mathrm{succ}(\mathrm{pred}(\mathrm{succ}(n)) = \mathrm{succ}(n)\)</span> by the second defining clause of the predecessor function.</p>
<p><strong>Proposition.</strong> For every <span class="math">\(n\)</span>, <span class="math">\(0 + n = n\)</span>.</p>
<p><strong>Proof.</strong> By induction on <span class="math">\(n\)</span>. We have <span class="math">\(0 + 0 = 0\)</span> by the first defining clause for addition. And assuming <span class="math">\(0 + n = n\)</span>, we have <span class="math">\(0 + \mathrm{succ}(n) = \mathrm{succ}(0 + n) = n\)</span>, using the second defining clause for addition.</p>
<p><strong>Proposition.</strong> For every <span class="math">\(m\)</span> and <span class="math">\(n\)</span>, <span class="math">\(\mathrm{succ}(m) + n = \mathrm{succ}(m + n)\)</span>.</p>
<p><strong>Proof.</strong> Fix <span class="math">\(m\)</span> and use induction on <span class="math">\(n\)</span>. Then <span class="math">\(n = 0\)</span>, we have <span class="math">\(\mathrm{succ}(m) + 0 = \mathrm{succ}(m) = \mathrm{succ}(m + 0)\)</span>, using the first defining clause for addition. Assuming the claim holds for <span class="math">\(n\)</span>, we have</p>
<div class="math">
\[\begin{split}\mathrm{succ}(m) + \mathrm{succ}(n) &amp; = \mathrm{succ}(\mathrm{succ}(m) + n) \\
&amp; = \mathrm{succ} (\mathrm{succ} (m + n)) \\
&amp; = \mathrm{succ} (m + \mathrm{succ}(n)),\end{split}\]</div>
<p>using the inductive hypothesis and the second defining clause for addition.</p>
<p><strong>Proposition.</strong> For every <span class="math">\(m\)</span>, <span class="math">\(n\)</span>, and <span class="math">\(k\)</span>, <span class="math">\((m + n) + k = m + (n + k)\)</span>.</p>
<p><strong>Proof.</strong> By induction on <span class="math">\(k\)</span>. The case where <span class="math">\(k = 0\)</span> is easy, and in the induction step we have</p>
<div class="math">
\[\begin{split}(m + n) + \mathrm{succ}(k) &amp; = \mathrm{succ} ((m + n) + k) \\
&amp; = \mathrm{succ} (m + (n + k)) \\
&amp; = m + \mathrm{succ} (n + k) \\
&amp; = m + (n + \mathrm{succ} (k)))\end{split}\]</div>
<p>using the inductive hypothesis and the definition of addition.</p>
<p><strong>Proposition.</strong> For every pair of natural numbers <span class="math">\(m\)</span> and <span class="math">\(n\)</span>, <span class="math">\(m + n = n + m\)</span>.</p>
<p><strong>Proof.</strong> By induction on <span class="math">\(n\)</span>. The base case is easy using the second proposition above. In the inductive step, we have</p>
<div class="math">
\[\begin{split}m + \mathrm{succ}(n) &amp; = \mathrm{succ}(m + n) \\
&amp; = \mathrm{succ} (n + m) \\
&amp; = \mathrm{succ}(n) + m\end{split}\]</div>
<p>using the third proposition above.</p>
</div>
<hr class="docutils" />
<div class="section" id="induction-and-recursion-in-lean">
<h2>18.2. Induction and Recursion in Lean<a class="headerlink" href="#induction-and-recursion-in-lean" title="Permalink to this headline">&#182;</a></h2>
<p>Internally, in Lean, the natural numbers are defined as a type generated inductively from an axiomatically declared <code class="docutils literal"><span class="pre">zero</span></code> and <code class="docutils literal"><span class="pre">succ</span></code> operation:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=namespace%20hide%0A%0A--%20BEGIN%0Ainductive%20nat%20:%20Type%0A%7C%20zero%20:%20nat%0A%7C%20succ%20:%20nat%20%E2%86%92%20nat%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
</pre></div>
</div>
</div><p>If you click the button that copies this text into the editor in the online version of this textbook, you will see that we wrap it with the phrases <code class="docutils literal"><span class="pre">namespace</span> <span class="pre">hide</span></code> and <code class="docutils literal"><span class="pre">end</span> <span class="pre">hide</span></code>. This puts the definition into a new &#8220;namespace,&#8221; so that the identifiers that are defined are <code class="docutils literal"><span class="pre">hide.nat</span></code>, <code class="docutils literal"><span class="pre">hide.nat.zero</span></code> and <code class="docutils literal"><span class="pre">hide.nat.succ</span></code>, to avoid conflicting with the one that is in the Lean library. Below, we will do that in a number of places where our examples duplicate objects defined in the library. The unicode symbol <code class="docutils literal"><span class="pre">&#8469;</span></code>, entered with <code class="docutils literal"><span class="pre">\N</span></code> or <code class="docutils literal"><span class="pre">\nat</span></code>, is a synonym for <code class="docutils literal"><span class="pre">nat</span></code>.</p>
<p>Declaring <code class="docutils literal"><span class="pre">nat</span></code> as an inductively defined type means that we can define functions by recursion, and prove theorems by induction. For example, these are the first two recursive definitions presented in the last chapter:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=open%20nat%0A%0Adef%20two_pow%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20%20%20%20:=%201%0A%7C%20(succ%20n)%20:=%202%20*%20two_pow%20n%0A%0Adef%20fact%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20%20%20%20:=%201%0A%7C%20(succ%20n)%20:=%20(succ%20n)%20*%20fact%20n" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">two_pow</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">two_pow</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">fact</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">fact</span> <span class="n">n</span>
</pre></div>
</div>
</div><p>Addition and numerals are defined in such a way that Lean recognizes <code class="docutils literal"><span class="pre">succ</span> <span class="pre">n</span></code> and <code class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> as essentially the same, so we could instead write these definitions as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=def%20two_pow%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20%20%20:=%201%0A%7C%20(n%20+%201)%20:=%202%20*%20two_pow%20n%0A%0Adef%20fact%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20%20%20:=%201%0A%7C%20(n%20+%201)%20:=%20(n%20+%201)%20*%20fact%20n" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">def</span> <span class="n">two_pow</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">two_pow</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">fact</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">fact</span> <span class="n">n</span>
</pre></div>
</div>
</div><p>If we wanted to define the function <code class="docutils literal"><span class="pre">m^n</span></code>, we would do that by fixing <code class="docutils literal"><span class="pre">m</span></code>, and writing doing the recursion on the second argument:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=def%20pow%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20m%200%20%20%20%20%20%20%20%20:=%201%0A%7C%20m%20(n%20+%201)%20%20:=%20m%20*%20pow%20m%20n" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">def</span> <span class="n">pow</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">pow</span> <span class="n">m</span> <span class="n">n</span>
</pre></div>
</div>
</div><p>Lean is also smart enough to interpret more complicated forms of recursion, like this one:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=def%20fib%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20%20%20%20:=%200%0A%7C%201%20%20%20%20%20%20%20%20:=%201%0A%7C%20(n%20+%202)%20%20:=%20fib%20(n%20+%201)%20+%20fib%20n" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span>        <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="n">n</span>
</pre></div>
</div>
</div><p>In addition to defining functions by recursion, we can prove theorems by induction. In Lean, each clause of a recursive definition results in a new identity. For example, the two clauses in the definition of <code class="docutils literal"><span class="pre">pow</span></code> above give rise to the following two theorems:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=def%20pow%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20m%200%20%20%20%20%20%20%20%20:=%201%0A%7C%20m%20(n%20+%201)%20%20:=%20m%20*%20pow%20m%20n%0A%0A--%20BEGIN%0Atheorem%20pow_zero%20(n%20:%20%E2%84%95)%20:%20pow%20n%200%20=%201%20:=%20rfl%0Atheorem%20pow_succ%20(m%20n%20:%20%E2%84%95)%20:%20pow%20m%20(n+1)%20=%20m%20*%20pow%20m%20n%20:=%20rfl%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">pow_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">pow</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">pow_succ</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">pow</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Notice that we could alternatively have used <code class="docutils literal"><span class="pre">(pow</span> <span class="pre">m</span> <span class="pre">n)</span> <span class="pre">*</span> <span class="pre">m</span></code> in the second clause of the definition of <code class="docutils literal"><span class="pre">pow</span></code>. Of course, we can prove that the two definitions are equivalent using the commutativity of multiplication, but, using a proof by induction, we can also prove it using only the associativity of multiplication, and the properties <code class="docutils literal"><span class="pre">1</span> <span class="pre">*</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">m</span></code> and <code class="docutils literal"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">m</span></code>. This is useful, because the power function is also often used in situations where multiplication is not commutative, such as with matrix multiplication. The theorem can be proved in Lean as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=open%20nat%0A%0Anamespace%20hide%0A%0Adefinition%20pow%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20m%200%20%20%20%20%20%20%20%20:=%201%0A%7C%20m%20(n%20+%201)%20%20:=%20m%20*%20(pow%20m%20n)%0A%0Atheorem%20pow_zero%20(n%20:%20%E2%84%95)%20:%20pow%20n%200%20=%201%20:=%20rfl%0Atheorem%20pow_succ%20(m%20n%20:%20%E2%84%95)%20:%20pow%20m%20(succ%20n)%20=%20m%20*%20(pow%20m%20n)%20:=%20rfl%0A%0A--%20BEGIN%0Atheorem%20pow_succ'%20(m%20n%20:%20%E2%84%95)%20:%20pow%20m%20(succ%20n)%20=%20(pow%20m%20n)%20*%20m%20:=%0Anat.rec_on%20n%0A%20%20(show%20pow%20m%20(succ%200)%20=%20pow%20m%200%20*%20m,%20from%20calc%0A%20%20%20%20pow%20m%20(succ%200)%20=%20m%20*%20pow%20m%200%20:%20by%20rw%20pow_succ%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%20*%201%20%20%20%20%20%20%20:%20by%20rw%20pow_zero%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%20%20%20%20%20%20%20%20%20%20%20:%20by%20rw%20mul_one%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%201%20*%20m%20%20%20%20%20%20%20:%20by%20rw%20one_mul%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20pow%20m%200%20*%20m%20:%20by%20rw%20pow_zero)%0A%20%20(assume%20n,%0A%20%20%20%20assume%20ih%20:%20pow%20m%20(succ%20n)%20=%20pow%20m%20n%20*%20m,%0A%20%20%20%20show%20pow%20m%20(succ%20(succ%20n))%20=%20pow%20m%20(succ%20n)%20*%20m,%20from%20calc%0A%20%20%20%20%20%20pow%20m%20(succ%20(succ%20n))%20=%20m%20*%20(pow%20m%20(succ%20n))%20:%20by%20rw%20pow_succ%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%20*%20(pow%20m%20n%20*%20m)%20%20%20%20:%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20(m%20*%20pow%20m%20n)%20*%20m%20%20%20%20:%20by%20rw%20mul_assoc%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20pow%20m%20(succ%20n)%20*%20m%20%20%20:%20by%20rw%20pow_succ)%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">pow_succ&#39;</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pow</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">show</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
    <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">pow</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_succ</span>
               <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="mi">1</span>       <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_zero</span>
               <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span>           <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_one</span>
               <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">m</span>       <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">one_mul</span>
               <span class="bp">...</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_zero</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="o">(</span><span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_succ</span>
                        <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="o">(</span><span class="n">pow</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="o">)</span>    <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">ih</span>
                        <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">*</span> <span class="n">pow</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span>    <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_assoc</span>
                        <span class="bp">...</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span>   <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_succ</span><span class="o">)</span>
</pre></div>
</div>
</div><p>This is a typical proof by induction in Lean. It begins with the phrase <code class="docutils literal"><span class="pre">nat.induction_on</span> <span class="pre">n</span></code>, and is followed by the base case and the inductive hypothesis. The proof can be shortened using <code class="docutils literal"><span class="pre">rewrite</span></code> and <code class="docutils literal"><span class="pre">simp</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=open%20nat%0A%0Anamespace%20hide%0A%0Adefinition%20pow%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%20m%200%20%20%20%20%20%20%20%20:=%201%0A%7C%20m%20(n%20+%201)%20%20:=%20m%20*%20(pow%20m%20n)%0A%0Atheorem%20pow_zero%20(n%20:%20%E2%84%95)%20:%20pow%20n%200%20=%201%20:=%20rfl%0Atheorem%20pow_succ%20(m%20n%20:%20%E2%84%95)%20:%20pow%20m%20(succ%20n)%20=%20m%20*%20(pow%20m%20n)%20:=%20rfl%0A%0A--%20BEGIN%0Atheorem%20pow_succ'%20(m%20n%20:%20%E2%84%95)%20:%20pow%20m%20(succ%20n)%20=%20(pow%20m%20n)%20*%20m%20:=%0Anat.rec_on%20n%0A%20%20(show%20pow%20m%20(succ%200)%20=%20pow%20m%200%20*%20m,%0A%20%20%20%20by%20rw%20%5Bpow_succ,%20pow_zero,%20mul_one,%20one_mul%5D)%0A%20%20(assume%20n,%0A%20%20%20%20assume%20ih%20:%20pow%20m%20(succ%20n)%20=%20pow%20m%20n%20*%20m,%0A%20%20%20%20show%20pow%20m%20(succ%20(succ%20n))%20=%20pow%20m%20(succ%20n)%20*%20m,%0A%20%20%20%20%20%20by%20simp%20%5Bpow_succ,%20ih%5D)%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">pow_succ&#39;</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pow</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">show</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span>
    <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">pow_zero</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">])</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">pow</span> <span class="n">m</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span>
      <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">ih</span><span class="o">])</span>
</pre></div>
</div>
</div><p>Remember that you can write a <code class="docutils literal"><span class="pre">rewrite</span></code> proof incrementally, checking the error messages to make sure things are working so far, and to see how far Lean got.</p>
<p>In any case, the power function is already defined in the Lean library as <code class="docutils literal"><span class="pre">pow_nat</span></code>. (It is defined generically for any type that has a multiplication; the <code class="docutils literal"><span class="pre">nat</span></code> in <code class="docutils literal"><span class="pre">pow_nat</span></code> refers to the fact that the exponent is a natural number.) The definition is essentially the one above, and the theorems above are also there:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=import%20algebra.group_power%0Alocal%20infix%20%60%20%5E%20%60%20:=%20pow_nat%0A%0A#check%20&#64;pow_nat%0A#check%20&#64;pow_zero%0A#check%20&#64;pow_succ%0A#check%20&#64;pow_succ'%0A%0Avariables%20m%20n%20:%20%E2%84%95%0A%0A#check%20m%5En" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">import</span> <span class="n">algebra.group_power</span>
<span class="kn">local</span> <span class="kd">infix</span> <span class="bp">`</span> <span class="bp">^</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">pow_nat</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">pow_nat</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">pow_zero</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">pow_succ</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">pow_succ&#39;</span>

<span class="kd">variables</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span>

<span class="k">#check</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span>
</pre></div>
</div>
</div><p>As another example of a proof by induction, here is a proof of the identity <code class="docutils literal"><span class="pre">m^(n</span> <span class="pre">+</span> <span class="pre">k)</span> <span class="pre">=</span> <span class="pre">m^n</span> <span class="pre">*</span> <span class="pre">m^k</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=import%20algebra.group_power%0Alocal%20infix%20%60%5E%60%20:=%20pow_nat%0A%0Anamespace%20hide%0Aexport%20nat%20(succ)%0A%0A--%20BEGIN%0Atheorem%20pow_add%20(m%20n%20k%20:%20%E2%84%95)%20:%20m%5E(n%20+%20k)%20=%20m%5En%20*%20m%5Ek%20:=%0Anat.rec_on%20k%0A%20%20(show%20m%5E(n%20+%200)%20=%20m%5En%20*%20m%5E0,%20from%20calc%0A%20%20%20%20m%5E(n%20+%200)%20=%20m%5En%20%20%20%20%20%20%20:%20by%20rw%20add_zero%0A%20%20%20%20%20%20%20%20%20%20...%20=%20m%5En%20*%201%20%20%20:%20by%20rw%20mul_one%0A%20%20%20%20%20%20%20%20%20%20...%20=%20m%5En%20*%20m%5E0%20:%20by%20rw%20pow_zero)%0A%20%20(assume%20k,%0A%20%20%20%20assume%20ih%20:%20m%5E(n%20+%20k)%20=%20m%5En%20*%20m%5Ek,%0A%20%20%20%20show%20m%5E(n%20+%20succ%20k)%20=%20m%5En%20*%20m%5E(succ%20k),%20from%20calc%0A%20%20%20%20%20%20m%5E(n%20+%20succ%20k)%20=%20m%5E(succ%20(n%20+%20k))%20:%20by%20rw%20nat.add_succ%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%5E(n%20+%20k)%20*%20m%20%20%20%20:%20by%20rw%20pow_succ'%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%5En%20*%20m%5Ek%20*%20m%20%20%20%20:%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%5En%20*%20(m%5Ek%20*%20m)%20%20:%20by%20rw%20mul_assoc%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%5En%20*%20m%5E(succ%20k)%20:%20by%20rw%20pow_succ')%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">pow_add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="n">k</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">k</span>
  <span class="o">(</span><span class="k">show</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
    <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span>       <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_zero</span>
          <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="mi">1</span>   <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_one</span>
          <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="mi">0</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_zero</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">k</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="n">k</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">),</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">nat.add_succ</span>
                 <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span>    <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_succ&#39;</span>
                 <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="n">k</span> <span class="bp">*</span> <span class="n">m</span>    <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">ih</span>
                 <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">m</span><span class="bp">^</span><span class="n">k</span> <span class="bp">*</span> <span class="n">m</span><span class="o">)</span>  <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_assoc</span>
                 <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">pow_succ&#39;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Notice the same pattern. This time, we do induction on <code class="docutils literal"><span class="pre">k</span></code>, and the base case and inductive step are routine. Once again, with a bit of cleverness, we can shorten the proof with <code class="docutils literal"><span class="pre">rewrite</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=import%20algebra.group_power%0Alocal%20infix%20%60%5E%60%20:=%20pow_nat%0A%0Anamespace%20hide%0Aexport%20nat%20(succ)%0A%0A--%20BEGIN%0Atheorem%20pow_add%20(m%20n%20k%20:%20%E2%84%95)%20:%20m%5E(n%20+%20k)%20=%20m%5En%20*%20m%5Ek%20:=%0Anat.rec_on%20k%0A%20%20(show%20m%5E(n%20+%200)%20=%20m%5En%20*%20m%5E0,%0A%20%20%20%20by%20rewrite%20%5Badd_zero,%20pow_zero,%20mul_one%5D)%0A%20%20(assume%20k,%0A%20%20%20%20assume%20ih%20:%20m%5E(n%20+%20k)%20=%20m%5En%20*%20m%5Ek,%0A%20%20%20%20show%20m%5E(n%20+%20succ%20k)%20=%20m%5En%20*%20m%5E(succ%20k),%0A%20%20%20%20%20by%20rewrite%20%5Bnat.add_succ,%20pow_succ',%20ih,%20mul_assoc,%20pow_succ'%5D)%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">pow_add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="n">k</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">k</span>
  <span class="o">(</span><span class="k">show</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="mi">0</span><span class="o">,</span>
    <span class="kd">by</span> <span class="n">rewrite</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">pow_zero</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">])</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">k</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="n">k</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="bp">^</span><span class="n">n</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">),</span>
     <span class="kd">by</span> <span class="n">rewrite</span> <span class="o">[</span><span class="n">nat.add_succ</span><span class="o">,</span> <span class="n">pow_succ&#39;</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">pow_succ&#39;</span><span class="o">])</span>
</pre></div>
</div>
</div><p>You should not hesitate to use <code class="docutils literal"><span class="pre">calc</span></code>, however, to make the proofs more explicit. Remember that you can also use <code class="docutils literal"><span class="pre">calc</span></code> and <code class="docutils literal"><span class="pre">rewrite</span></code> together, using <code class="docutils literal"><span class="pre">calc</span></code> to structure the calculational proof, and using <code class="docutils literal"><span class="pre">rewrite</span></code> to fill in each justification step.</p>
</div>
<div class="section" id="defining-the-arithmetic-operations-in-lean">
<h2>18.3. Defining the Arithmetic Operations in Lean<a class="headerlink" href="#defining-the-arithmetic-operations-in-lean" title="Permalink to this headline">&#182;</a></h2>
<p>In fact, addition and multiplication are defined in Lean essentially as described in <a class="reference internal" href="#defining-arithmetic-operations"><span class="std std-numref">Section 18.1</span></a>. The defining equations for addition hold by reflexivity, but they are also named <code class="docutils literal"><span class="pre">add_zero</span></code> and <code class="docutils literal"><span class="pre">add_succ</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=open%20nat%0A%0Avariables%20m%20n%20:%20%E2%84%95%0A%0Aexample%20:%20m%20+%200%20=%20m%20:=%20add_zero%20m%0Aexample%20:%20m%20+%20succ%20n%20=%20succ%20(m%20+%20n)%20:=%20add_succ%20m%20n" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">nat</span>

<span class="kd">variables</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">add_zero</span> <span class="n">m</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">add_succ</span> <span class="n">m</span> <span class="n">n</span>
</pre></div>
</div>
</div><p>Similarly, we have the defining equations for the predecessor function
and multiplication:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=open%20nat%0A%0A#check%20&#64;pred_zero%0A#check%20&#64;pred_succ%0A#check%20&#64;mul_zero%0A#check%20&#64;mul_succ" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">open</span> <span class="n">nat</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">pred_zero</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">pred_succ</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_zero</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_succ</span>
</pre></div>
</div>
</div><p>Here are the five propositions proved in <a class="reference internal" href="#defining-arithmetic-operations"><span class="std std-numref">Section 18.1</span></a>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/master/#code=open%20nat%0A%0Anamespace%20hide%0A%0A--%20BEGIN%0Atheorem%20succ_pred%20(n%20:%20%E2%84%95)%20:%20n%20%E2%89%A0%200%20%E2%86%92%20succ%20(pred%20n)%20=%20n%20:=%0Anat.rec_on%20n%0A%20%20(assume%20H%20:%200%20%E2%89%A0%200,%0A%20%20%20%20show%20succ%20(pred%200)%20=%200,%20from%20absurd%20rfl%20H)%0A%20%20(assume%20n,%0A%20%20%20%20assume%20ih,%0A%20%20%20%20assume%20H%20:%20succ%20n%20%E2%89%A0%200,%0A%20%20%20%20show%20succ%20(pred%20(succ%20n))%20=%20succ%20n,%0A%20%20%20%20%20%20by%20rewrite%20pred_succ)%0A%0Atheorem%20zero_add%20(n%20:%20nat)%20:%200%20+%20n%20=%20n%20:=%0Anat.rec_on%20n%0A%20%20(show%200%20+%200%20=%200,%20from%20rfl)%0A%20%20(assume%20n,%0A%20%20%20%20assume%20ih%20:%200%20+%20n%20=%20n,%0A%20%20%20%20show%200%20+%20succ%20n%20=%20succ%20n,%20from%0A%20%20%20%20%20%20calc%0A%20%20%20%200%20+%20succ%20n%20=%20succ%20(0%20+%20n)%20:%20rfl%0A%20%20%20%20%20%20...%20=%20succ%20n%20:%20by%20rw%20ih)%0A%0Atheorem%20succ_add%20(m%20n%20:%20nat)%20:%20succ%20m%20+%20n%20=%20succ%20(m%20+%20n)%20:=%0Anat.rec_on%20n%0A%20%20(show%20succ%20m%20+%200%20=%20succ%20(m%20+%200),%20from%20rfl)%0A%20%20(assume%20n,%0A%20%20%20%20assume%20ih%20:%20succ%20m%20+%20n%20=%20succ%20(m%20+%20n),%0A%20%20%20%20show%20succ%20m%20+%20succ%20n%20=%20succ%20(m%20+%20succ%20n),%20from%0A%20%20%20%20%20%20calc%0A%20%20%20%20succ%20m%20+%20succ%20n%20=%20succ%20(succ%20m%20+%20n)%20:%20rfl%0A%20%20%20%20%20%20...%20=%20succ%20(succ%20(m%20+%20n))%20:%20by%20rw%20ih%0A%20%20%20%20%20%20...%20=%20succ%20(m%20+%20succ%20n)%20:%20rfl)%0A%0Atheorem%20add_assoc%20(m%20n%20k%20:%20nat)%20:%20m%20+%20n%20+%20k%20=%20m%20+%20(n%20+%20k)%20:=%0Anat.rec_on%20k%0A%20%20(show%20m%20+%20n%20+%200%20=%20m%20+%20(n%20+%200),%20by%20rw%20%5Badd_zero,%20add_zero%5D)%0A%20%20(assume%20k,%0A%20%20%20%20assume%20ih%20:%20m%20+%20n%20+%20k%20=%20m%20+%20(n%20+%20k),%0A%20%20%20%20show%20m%20+%20n%20+%20succ%20k%20=%20m%20+%20(n%20+%20(succ%20k)),%20from%20calc%0A%20%20%20%20%20%20m%20+%20n%20+%20succ%20k%20=%20succ%20(m%20+%20n%20+%20k)%20%20%20:%20by%20rw%20add_succ%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20succ%20(m%20+%20(n%20+%20k))%20:%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20m%20+%20(n%20+%20succ%20k)%20%20%20:%20by%20rw%20add_succ)%0A%0Atheorem%20add_comm%20(m%20n%20:%20nat)%20:%20m%20+%20n%20=%20n%20+%20m%20:=%0Anat.rec_on%20n%0A%20%20(show%20m%20+%200%20=%200%20+%20m,%20by%20rewrite%20%5Badd_zero,%20zero_add%5D)%0A%20%20(assume%20n,%0A%20%20%20%20assume%20ih%20:%20m%20+%20n%20=%20n%20+%20m,%0A%20%20%20%20show%20m%20+%20succ%20n%20=%20succ%20n%20+%20m,%20from%20calc%0A%20%20%20%20%20%20m%20+%20succ%20n%20=%20succ%20(m%20+%20n)%20:%20by%20rw%20add_succ%0A%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20succ%20(n%20+%20m)%20:%20by%20rw%20ih%0A%20%20%20%20%20%20%20%20%20%20%20%20%20...%20=%20succ%20n%20+%20m%20%20%20:%20by%20rw%20succ_add)%0A%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">succ_pred</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&#8800;</span> <span class="mi">0</span> <span class="bp">&#8594;</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">H</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8800;</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">absurd</span> <span class="n">rfl</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">H</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">&#8800;</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">succ</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span>
      <span class="kd">by</span> <span class="n">rewrite</span> <span class="n">pred_succ</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">zero_add</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span>
      <span class="k">calc</span>
    <span class="mi">0</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">ih</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">succ_add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">show</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">),</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">),</span>
    <span class="k">show</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span><span class="o">),</span> <span class="k">from</span>
      <span class="k">calc</span>
    <span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">ih</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">add_assoc</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">k</span>
  <span class="o">(</span><span class="k">show</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">),</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">])</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">k</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">),</span>
    <span class="k">show</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)),</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span>   <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_succ</span>
                 <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">ih</span>
                 <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">k</span><span class="o">)</span>   <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_succ</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">add_comm</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">nat.rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">show</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rewrite</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">])</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">add_succ</span>
             <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">ih</span>
             <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>   <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">succ_add</span><span class="o">)</span>
</pre></div>
</div>
</div></div>
<div class="section" id="exercises">
<h2>18.4. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic simple">
<li>Give an informal but detailed proof that for every natural number <span class="math">\(n\)</span>, <span class="math">\(1 \cdot n = n\)</span>.</li>
<li>Prove the multiplication is associative and commutative, in the same way.</li>
<li>Prove that multiplication distributes over addition: for every natural numbers <span class="math">\(m\)</span>, <span class="math">\(n\)</span>, and <span class="math">\(k\)</span>, <span class="math">\(m (n + k) = m n + m k\)</span>.</li>
<li>Prove <span class="math">\((m^n)^k = m^{nk}\)</span>.</li>
<li>Formalize all these theorems in Lean.</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">15. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">18. The Natural Numbers and Induction in Lean</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#defining-arithmetic-operations">18.1. Defining Arithmetic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#induction-and-recursion-in-lean">18.2. Induction and Recursion in Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-the-arithmetic-operations-in-lean">18.3. Defining the Arithmetic Operations in Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">18.4. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory_in_lean.html">20. Elementary Number Theory in Lean</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/the_natural_numbers_and_induction_in_lean.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>